# 🎯 C++ Reflection System

一个轻量级、现代化的 **C++ 运行时反射系统**，支持：
- 动态注册类、字段、方法
- 动态创建对象实例（含构造参数）
- 运行时访问/设置字段
- 动态方法调用（支持参数传递和返回值）

---

## 📦 项目简介

该反射系统使用了 **C++17/20** 的新特性，包括：
- `std::any`：实现类型擦除，统一存储任意字段和方法参数
- `std::unique_ptr`：智能内存管理
- 可变参数模板 + `std::index_sequence`：实现泛型的成员方法调用器
- 类注册、字段注册、方法注册、对象工厂抽象接口设计

> 类似于 Java/C# 中的反射系统，是构建脚本系统、插件系统、序列化框架、可视化编辑器等的基础组件。

---

## ✨ 当前功能

- ✅ 类名注册（自定义类名）
- ✅ 字段注册和字段值访问（支持 `int`、`std::string`）
- ✅ 方法注册与动态调用（支持参数传递和返回值）
- ✅ 动态创建对象（默认构造 & 带参构造）
- ✅ 方法调用参数校验与异常处理
- ✅ 查询类的全部方法名
- ✅ 获取类的所有字段值

---

## 🧩 项目结构

- `Reflection.h`：反射系统核心类与接口定义
- `Reflection.cpp`：接口实现，包括哈希函数、注册中心逻辑等

---

## 📌 项目现状

目前系统已经可以用于实际工程中的基础反射功能，包括：

- 成功支持字段和方法的运行时调用
- 工厂系统可创建带参和无参对象
- 支持运行时方法和字段查询
- 提供统一的注册中心 `ReflectionRegistry` 管理所有类信息

代码结构清晰，易于扩展，已初步具备实际应用能力。

---

## ⚠️ 存在的不足

虽然系统功能完整，但目前仍存在以下问题：

1. **类型转换不够智能**：
   - 使用 `std::any_cast` 时，如果类型不匹配会抛出 `std::bad_any_cast`，缺乏友好的错误提示。

2. **字段类型支持有限**：
   - 目前仅支持 `int` 和 `std::string`，其他类型需手动扩展。

3. **使用 `typeid(T).name()` 获取类名存在跨平台兼容性问题**：
   - GCC、Clang 和 MSVC 返回的类型名格式不同，可能导致注册失败。

4. **内存管理复杂性高**：
   - 使用 `std::unique_ptr<void, void(*)(void*)>` 来管理对象内存较为危险，`void*` 不具备类型安全。

5. **缺乏线程安全保证**：
   - `ReflectionRegistry` 尚未引入锁机制，不能保证多线程注册/调用安全。

6. **错误处理机制不一致**：
   - 有些函数通过异常处理，有些则直接返回空值，接口不够统一。

---

## 🚀 未来更新方向

计划中的更新包括：

### ✅ 类型系统完善
- 支持更多基本类型（如 `float`、`bool`、`double` 等）
- 支持用户自定义类型（如枚举、结构体）

### ✅ 错误处理优化
- 增加类型校验提示，避免 `std::bad_any_cast`
- 改用 `std::optional` 或 `Result<T, Error>` 风格接口返回调用结果

### ✅ 工厂接口重构
- 使用 `std::shared_ptr<void>` 替代 `unique_ptr<void, void(*)(void*)>`，提升安全性
- 或引入模板化工厂，简化对象生命周期管理

### ✅ 类型注册统一处理
- 引入统一的 `demangleTypeName()`（支持 GCC/Clang）统一解析类型名

### ✅ 多线程支持
- 使用 `std::mutex` 对 `ReflectionRegistry` 的访问加锁
- 提供线程安全版本接口

### ✅ 自动注册宏
- 提供宏定义简化用户注册类/字段/方法的流程，如：
  ```cpp
  REGISTER_CLASS(MyClass)
  REGISTER_METHOD(MyClass, foo)
  REGISTER_FIELD(MyClass, bar)
